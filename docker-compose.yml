# Описываем наши сервисы (контейнеры)
services:

  # Сервис №1: Наше FastAPI-приложение
  app:
    # Указываем Docker Compose, что образ нужно собрать из Dockerfile
    # в текущей директории ('.')
    build: .
    # Имя для нашего образа, чтобы его было легко найти
    image: metric-collector-app
    # Переменные окружения, которые будут переданы в контейнер.
    # Docker Compose автоматически подхватит их из файла .env!
    # Наш код на Python (через pydantic-settings) их прочитает.
    env_file:
      - .env
    # Пробрасываем порты. Формат: 'ПОРТ_НА_ХОСТЕ:ПОРТ_В_КОНТЕЙНЕРЕ'
    # Мы "выставляем" порт 8000 из контейнера наружу на порт 8000 нашего компьютера.
    ports:
      - "8000:8000"
    # Указываем, что наш сервис `app` должен стартовать только ПОСЛЕ
    # того, как сервис `db` будет готов.
    depends_on:
      - db

  # Сервис №2: База данных PostgreSQL
  db:
    # Используем готовый официальный образ PostgreSQL с Docker Hub.
    # Не нужно писать для него Dockerfile.
    image: postgres:15-alpine
    # Переменные окружения для инициализации контейнера PostgreSQL.
    # Имена этих переменных (POSTGRES_USER и т.д.) определены
    # в документации к официальному образу postgres.
    # ВАЖНО: значения здесь должны совпадать со значениями в вашем .env файле!
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
      POSTGRES_DB: ${DB_NAME}
    # Пробрасываем порт, чтобы мы могли подключиться к БД с нашего компьютера
    # с помощью psql или DBeaver для отладки.
    ports:
      - "5432:5432"
    # Указываем "volume" (том). Это способ сохранить данные БД
    # даже если мы удалим контейнер. Docker создаст на хосте папку
    # `postgres_data` и будет хранить в ней все данные.
    volumes:
      - postgres_data:/var/lib/postgresql/data/
      - ./db_init:/docker-entrypoint-initdb.d

# Описываем "volumes", которые мы используем
volumes:
  postgres_data:
